### CONTEXT PATHS ###
session_utils.rs
matchmaking/session.rs
matchmaking/types.rs
matchmaking/server.rs
matchmaking/mod.rs
matchmaking/messages.rs
game_session/session.rs
game_session/turn_resolution.rs
game_session/server.rs
game_session/mod.rs
game_session/mode_choice.rs
game_session/messages.rs
mod.rs
state.rs
router.rs
ws_actor_utils.rs
ws_error.rs
anti_spam.rs

backend/src/server/session_utils.rs:
use actix::Addr;
use std::collections::HashMap;
use std::hash::Hash;
use std::cmp::PartialEq;

use crate::server::matchmaking::types::WalletAddress;
use crate::server::matchmaking::server::ConnectedPlayer;
use crate::server::game_session::session::GameSessionActor;
use crate::server::matchmaking::session::MatchmakingSession;

/// Fonction générique pour vérifier si une adresse correspond à celle enregistrée pour une clé donnée.
/// Retourne true si l'adresse est bien celle attendue.
pub fn is_addr_valid<K, V, A>(
    map: &HashMap<K, V>,
    key: &K,
    addr: &A,
    addr_extractor: impl Fn(&V) -> &A,
) -> bool
where
    K: Eq + Hash,
    A: PartialEq,
{
    map.get(key).map_or(false, |value| addr_extractor(value) == addr)
}

/// Fonction générique pour récupérer une valeur si l'adresse correspond à celle enregistrée.
/// Retourne None si la clé n'existe pas ou si l'adresse ne correspond pas.
pub fn get_by_addr<'a, K, V, A>(
    map: &'a HashMap<K, V>,
    key: &K,
    addr: &A,
    addr_extractor: impl Fn(&V) -> &A,
) -> Option<&'a V>
where
    K: Eq + Hash,
    A: PartialEq,
{
    map.get(key).filter(|value| addr_extractor(value) == addr)
}

/// Vérifie si l'adresse de session correspond à celle enregistrée pour ce wallet dans le matchmaking.
/// Retourne true si la session est bien celle attendue.
pub fn is_matchmaking_session_addr_valid(
    players: &HashMap<WalletAddress, ConnectedPlayer>,
    player_id: &WalletAddress,
    addr: &Addr<MatchmakingSession>,
) -> bool {
    is_addr_valid(players, player_id, addr, |player| &player.addr)
}

/// Récupère un joueur connecté si l'adresse de session correspond à celle enregistrée pour ce wallet.
/// Retourne None si le joueur n'existe pas ou si l'adresse ne correspond pas.
pub fn get_player_by_matchmaking_addr<'a>(
    players: &'a HashMap<WalletAddress, ConnectedPlayer>,
    player_id: &WalletAddress,
    addr: &Addr<MatchmakingSession>,
) -> Option<&'a ConnectedPlayer> {
    get_by_addr(players, player_id, addr, |player| &player.addr)
}

/// Vérifie si l'adresse de session correspond à celle enregistrée pour ce wallet dans la game session.
/// Retourne true si la session est bien celle attendue.
pub fn is_game_session_addr_valid(
    players: &HashMap<WalletAddress, Addr<GameSessionActor>>,
    player_id: &WalletAddress,
    addr: &Addr<GameSessionActor>,
) -> bool {
    is_addr_valid(players, player_id, addr, |a| a)
}

/// Récupère l'adresse d'une session de jeu si l'adresse fournie correspond à celle enregistrée pour ce wallet.
/// Retourne None si le joueur n'existe pas ou si l'adresse ne correspond pas.
pub fn get_player_by_game_session_addr<'a>(
    players: &'a HashMap<WalletAddress, Addr<GameSessionActor>>,
    player_id: &WalletAddress,
    addr: &Addr<GameSessionActor>,
) -> Option<&'a Addr<GameSessionActor>> {
    get_by_addr(players, player_id, addr, |a| a)
}

/// Vérifie si l'adresse de session correspond à celle enregistrée pour ce wallet dans la liste des spectateurs.
/// Retourne true si la session est bien celle attendue.
pub fn is_game_session_spectator_addr_valid(
    spectators: &HashMap<WalletAddress, Addr<GameSessionActor>>,
    wallet: &WalletAddress,
    addr: &Addr<GameSessionActor>,
) -> bool {
    is_addr_valid(spectators, wallet, addr, |a| a)
}

backend/src/server/matchmaking/session.rs:

/// WebSocket session handler for a player in the matchmaking lobby.
///
/// Handles incoming client messages (pay, cancel, ping, etc.) and relays server updates.
/// Centralizes error handling and ensures all business logic is executed.

use actix::{Addr, Actor, StreamHandler, Handler, ActorContext, AsyncContext};
use actix_web::{HttpRequest, HttpResponse, web, Error};
use actix_web_actors::ws;
use serde_json::json;
use log::{info, warn, error, debug};

use crate::server::matchmaking::server::{MatchmakingServer, Join, Leave, Pay, CancelPayment};
use crate::server::matchmaking::messages::{ServerWsMessage, ClientWsMessage, SessionKicked};
use crate::server::matchmaking::types::WalletAddress;
use crate::server::ws_error::{http_error_response, ws_session_kicked_message};
use crate::server::anti_spam::AntiSpamState;
use crate::server::ws_actor_utils::WsActorUtils;

/// Represents a WebSocket session for a player in the matchmaking lobby.
pub struct MatchmakingSession {
    pub player_id: WalletAddress,
    pub username: String,
    pub matchmaking_addr: Addr<MatchmakingServer>,
    pub anti_spam: AntiSpamState,
}

impl Actor for MatchmakingSession {
    type Context = ws::WebsocketContext<Self>;

    /// Register this session with the matchmaking server.
    fn started(&mut self, ctx: &mut Self::Context) {
        info!(
            "[Matchmaking WS] Session started for wallet={} username={}",
            self.player_id, self.username
        );
        // Register this session with the matchmaking server.
        self.matchmaking_addr.do_send(Join {
            player_id: self.player_id.clone(),
            addr: ctx.address(),
            username: self.username.clone(),
        });
    }

    /// Unregister this session from the matchmaking server.
    fn stopped(&mut self, ctx: &mut Self::Context) {
        info!(
            "[Matchmaking WS] Session stopped for wallet={} username={}",
            self.player_id, self.username
        );
        self.matchmaking_addr.do_send(Leave {
            player_id: self.player_id.clone(),
            addr: ctx.address(),
        });
    }
}

impl WsActorUtils for MatchmakingSession {
    fn anti_spam(&mut self) -> &mut AntiSpamState {
        &mut self.anti_spam
    }
    
    fn player_id(&self) -> &str {
        &self.player_id
    }
}

impl StreamHandler<Result<ws::Message, ws::ProtocolError>> for MatchmakingSession {
    fn handle(&mut self, msg: Result<ws::Message, ws::ProtocolError>, ctx: &mut Self::Context) {
        // Anti-spam: record request, close if banned
        let player_id = self.player_id().to_string();
        if self.anti_spam().record_request(&player_id) {
            self.send_ban_and_close(ctx);
            return;
        }

        match msg {
            Ok(ws::Message::Text(ref text)) => {
                info!(
                    "[Matchmaking WS] Message received from wallet={}: {}",
                    self.player_id, text
                );
                // Parse the client message as JSON.
                let msg: ClientWsMessage = match serde_json::from_str(text) {
                    Ok(m) => m,
                    Err(e) => {
                        warn!(
                            "[Matchmaking WS] Invalid command from wallet={}: {} | Text: {}",
                            self.player_id, e, text
                        );
                        // Anti-spam: suppress duplicate errors
                        self.send_error_and_maybe_ban(ctx, "INVALID_ACTION", "Invalid command", None);
                        return;
                    }
                };
                debug!(
                    "[Matchmaking WS] Successfully parsed client message for wallet={}: {:?}",
                    self.player_id, msg
                );
                // Handle the parsed client message.
                match msg {
                    ClientWsMessage::Pay => {
                        self.matchmaking_addr.do_send(Pay {
                            player_id: self.player_id.clone(),
                            addr: ctx.address(),
                        });
                        self.anti_spam().reset_on_valid_action();
                    }
                    ClientWsMessage::CancelPayment => {
                        self.matchmaking_addr.do_send(CancelPayment {
                            player_id: self.player_id.clone(),
                            addr: ctx.address(),
                        });
                        self.anti_spam().reset_on_valid_action();
                    }
                    ClientWsMessage::Ping => {
                        debug!("[Matchmaking WS] Received Ping from wallet={}", self.player_id);
                        // Optionally, respond or ignore.
                    }
                }
            }
            Ok(ws::Message::Ping(msg)) => ctx.pong(&msg),
            Ok(ws::Message::Close(_)) => {
                info!("[Matchmaking WS] Connection closed: wallet={}", self.player_id);
                ctx.stop();
            }
            Ok(other) => {
                warn!(
                    "[Matchmaking WS] Ignored WebSocket message from wallet={}: {:?}",
                    self.player_id, other
                );
            }
            Err(e) => {
                error!(
                    "[Matchmaking WS] WebSocket error: wallet={} err={:?}",
                    self.player_id, e
                );
                self.send_error_and_maybe_ban(ctx, "WS_PROTOCOL_ERROR", "WebSocket protocol error", None);
                ctx.stop();
            }
        }
    }
}

impl Handler<SessionKicked> for MatchmakingSession {
    type Result = ();

    /// Handles the session being kicked from the server.
    fn handle(&mut self, _msg: SessionKicked, ctx: &mut Self::Context) -> Self::Result {
        info!("[Matchmaking WS] Session kicked: wallet={}", self.player_id);
        ctx.text(ws_session_kicked_message(Some(json!({
            "wallet": self.player_id
        }))));
        ctx.stop();
    }
}

impl Handler<ServerWsMessage> for MatchmakingSession {
    type Result = ();

    /// Handles messages sent from the server to this session.
    fn handle(&mut self, msg: ServerWsMessage, ctx: &mut Self::Context) {
        match serde_json::to_string(&msg) {
            Ok(text) => {
                self.send_json_or_ban(ctx, text);
            },
            Err(e) => {
                error!(
                    "[Matchmaking WS] Failed to serialize ServerWsMessage for wallet={}: {}",
                    self.player_id, e
                );
                self.send_error_and_maybe_ban(ctx, "SERIALIZATION_ERROR", "Internal server error", None);
                ctx.close(Some(ws::CloseReason {
                    code: ws::CloseCode::Error,
                    description: Some("Internal server error".into()),
                }));
                ctx.stop();
            }
        }
    }
}

/// WebSocket endpoint for matchmaking lobby.
///
/// Expects query parameters: `wallet` (player address), `username` (optional).
/// If username is missing, a default is generated from the wallet address.
pub async fn ws_matchmaking(
    req: HttpRequest,
    stream: web::Payload,
    data: web::Data<crate::server::state::AppState>,
) -> Result<HttpResponse, Error> {
    use std::borrow::Cow;
    let mut player_id: Option<WalletAddress> = None;
    let mut username = String::new();

    // Parse query parameters for wallet and username.
    for kv in req.query_string().split('&') {
        let mut split = kv.split('=');
        match (split.next(), split.next()) {
            (Some("wallet"), Some(addr)) => {
                player_id = Some(addr.to_string());
            }
            (Some("username"), Some(name)) => {
                username = urlencoding::decode(name)
                    .unwrap_or_else(|_| Cow::Borrowed(""))
                    .into_owned();
            }
            _ => {}
        }
    }

    // Reject connection if wallet address is missing.
    let player_id = match player_id {
        Some(addr) if !addr.is_empty() => addr,
        _ => {
            warn!("[Matchmaking WS] Connection refused: missing wallet address");
            return Ok(http_error_response(
                "MISSING_WALLET",
                "Missing wallet address",
                None,
                actix_web::http::StatusCode::BAD_REQUEST,
            ));
        }
    };

    // If username is empty, generate a default one.
    if username.is_empty() {
        username = format!("Joueur_{}", &player_id[..6]);
    }

    ws::start(
        MatchmakingSession {
            player_id,
            username,
            matchmaking_addr: data.matchmaking_addr.clone(),
            anti_spam: AntiSpamState::new(),
        },
        &req,
        stream,
    )
}

backend/src/server/matchmaking/types.rs:
/// Types used in the matchmaking module.

use serde::{Serialize, Deserialize};

/// Alias for a player's wallet address (unique identifier).
pub type WalletAddress = String;

/// Information about a player in the matchmaking lobby or game.
#[derive(Clone, Serialize, Deserialize, Debug)]
pub struct PlayerInfo {
    /// Unique wallet address of the player.
    pub id: WalletAddress,
    /// Display username.
    pub username: String,
}
backend/src/server/matchmaking/server.rs:
/// Matchmaking server actor.
///
/// Manages the matchmaking lobby, player readiness, countdowns, and game creation.
/// Handles player join/leave, payment, and cancellation, and coordinates with the game session manager.

use actix::prelude::*;
use std::collections::HashMap;
use std::time::{Duration, Instant};
use uuid::Uuid;
use log::{info, debug};

use super::types::{PlayerInfo, WalletAddress};
use super::messages::{ServerWsMessage, MatchmakingState};
use super::session::MatchmakingSession;
use crate::config::matchmaking::{MIN_PLAYERS, MAX_PLAYERS, COUNTDOWN_DURATION_SECS};
use crate::server::game_session::messages::RegisterPendingGame;
use crate::server::game_session::server::GameSessionManager;
use crate::server::session_utils::is_matchmaking_session_addr_valid;

type SessionAddr = Addr<MatchmakingSession>;

use crate::server::matchmaking::messages::SessionKicked;


/// Represents a player currently connected to the lobby or ready group.
#[derive(Debug, Clone)]
pub struct ConnectedPlayer {
    pub info: PlayerInfo,
    pub addr: SessionAddr,
}

/// Handle for an active countdown timer.
struct CountdownHandle {
    handle: SpawnHandle,
    start_time: Instant,
}

/// Main matchmaking server actor.
pub struct MatchmakingServer {
    /// Players in the lobby (not yet ready).
    lobby_players: HashMap<WalletAddress, ConnectedPlayer>,
    /// Groups of players who have paid and are ready to play.
    ready_groups: Vec<HashMap<WalletAddress, ConnectedPlayer>>,
    /// Active countdown timer, if any.
    countdown: Option<CountdownHandle>,
    /// Address of the game session manager for launching games.
    game_session_manager: Addr<GameSessionManager>,
}

impl MatchmakingServer {
    /// Create a new matchmaking server.
    pub fn new(game_session_manager: Addr<GameSessionManager>) -> Self {
        Self {
            lobby_players: HashMap::new(),
            ready_groups: Vec::new(),
            countdown: None,
            game_session_manager,
        }
    }

    /// Broadcast a message to all players in the lobby and ready groups.
    fn broadcast(&self, msg: ServerWsMessage) {
        for player in self.lobby_players.values() {
            player.addr.do_send(msg.clone());
        }
        for group in &self.ready_groups {
            for player in group.values() {
                player.addr.do_send(msg.clone());
            }
        }
    }

    /// Send the current matchmaking state to all clients.
    fn send_state(&self) {
        let state = self.get_state();
        self.broadcast(ServerWsMessage::UpdateState(state));
    }

    /// Build the current matchmaking state.
    fn get_state(&self) -> MatchmakingState {
        let countdown_active = self.countdown.is_some();
        let countdown_remaining = self.countdown.as_ref().map(|c| {
            COUNTDOWN_DURATION_SECS.saturating_sub(c.start_time.elapsed().as_secs())
        });
        let ready_players: Vec<PlayerInfo> = self.ready_groups
            .iter()
            .flat_map(|group| group.values().map(|p| p.info.clone()))
            .collect();
        MatchmakingState {
            lobby_players: self.lobby_players.values().map(|p| p.info.clone()).collect(),
            ready_players,
            countdown_active,
            countdown_remaining,
        }
    }

    /// Start the countdown timer for the next game if not already started.
    fn start_countdown(&mut self, ctx: &mut Context<Self>) {
        if self.countdown.is_some() {
            // Countdown already active; do nothing.
            return;
        }
        self.send_state();
        let handle = ctx.run_later(Duration::from_secs(COUNTDOWN_DURATION_SECS), |act, ctx| {
            act.try_launch_next_game(ctx);
        });
        self.countdown = Some(CountdownHandle {
            handle,
            start_time: Instant::now(),
        });
        info!("[Matchmaking] Countdown started for next group");
    }

    /// Cancel the countdown timer if active.
    fn cancel_countdown(&mut self, ctx: &mut Context<Self>) {
        if let Some(countdown) = self.countdown.take() {
            ctx.cancel_future(countdown.handle);
            self.send_state();
            info!("[Matchmaking] Countdown cancelled");
        }
    }

    /// Attempt to launch the next game if a ready group has enough players.
    fn try_launch_next_game(&mut self, ctx: &mut Context<Self>) {
        // Find a group with enough players to start a game.
        if let Some((group_idx, group)) = self.ready_groups.iter().enumerate().find(|(_, g)| g.len() >= MIN_PLAYERS) {
            let player_infos: Vec<PlayerInfo> = group.values().map(|p| p.info.clone()).collect();
            let player_addrs: Vec<SessionAddr> = group.values().map(|p| p.addr.clone()).collect();

            // Remove the countdown since the game is starting.
            self.cancel_countdown(ctx);

            // Generate a new game ID.
            let game_id = Uuid::new_v4();

            // Register the pending game with the game session manager.
            self.game_session_manager.do_send(RegisterPendingGame {
                game_id,
                players: player_infos.clone(),
            });

            // Notify each player of the new game.
            for addr in &player_addrs {
                addr.do_send(ServerWsMessage::GameStarted { game_id });
            }

            info!("[Matchmaking] Game created with {} players, game_id={}", player_addrs.len(), game_id);

            // Remove the group from the ready list.
            if group_idx < self.ready_groups.len() {
                self.ready_groups.remove(group_idx);
            }
            self.send_state();
        }
    }

    /// Add or update a player in the lobby.
    fn add_or_update_lobby_player(&mut self, player_id: WalletAddress, addr: SessionAddr, username: String) {
        let player_info = PlayerInfo {
            id: player_id.clone(),
            username,
        };
        self.lobby_players.insert(player_id, ConnectedPlayer {
            info: player_info,
            addr,
        });
    }

    /// Remove a player from all ready groups, but only if the session address matches.
    fn remove_player_from_ready_groups(&mut self, player_id: &WalletAddress, addr: &SessionAddr) -> Option<ConnectedPlayer> {
        for group in &mut self.ready_groups {
            if let Some(_player) = group.get(player_id) {
                if is_matchmaking_session_addr_valid(group, player_id, addr) {
                    return group.remove(player_id);
                }
            }
        }
        None
    }

    /// Find the ready group containing the given player, mutably.
    fn find_group_of_player_mut(&mut self, player_id: &WalletAddress) -> Option<&mut HashMap<WalletAddress, ConnectedPlayer>> {
        self.ready_groups.iter_mut().find(|g| g.contains_key(player_id))
    }

    /// Refund a player (stub for business logic).
    fn refund_player(&self, player_id: &WalletAddress) {
        // TODO: Implement refund logic if needed.
        debug!("[Matchmaking] Refund requested for player {}", player_id);
    }
}

/// Message: player joins the lobby.
#[derive(Message)]
#[rtype(result = "()")]
pub struct Join {
    pub player_id: WalletAddress,
    pub addr: SessionAddr,
    pub username: String,
}

/// Message: player leaves the lobby or ready group.
#[derive(Message)]
#[rtype(result = "()")]
pub struct Leave {
    pub player_id: WalletAddress,
    pub addr: SessionAddr,
}

/// Message: player pays to become ready.
#[derive(Message)]
#[rtype(result = "()")]
pub struct Pay {
    pub player_id: WalletAddress,
    pub addr: SessionAddr,
}

/// Message: player cancels payment and returns to lobby.
#[derive(Message)]
#[rtype(result = "()")]
pub struct CancelPayment {
    pub player_id: WalletAddress,
    pub addr: SessionAddr,
}

impl Actor for MatchmakingServer {
    type Context = Context<Self>;
}

impl Handler<Join> for MatchmakingServer {
    type Result = ();

    /// Handles a player joining the lobby.
    fn handle(&mut self, msg: Join, _ctx: &mut Self::Context) -> Self::Result {
        // If the player is already in a ready group, kick the old session and update their address.
        if let Some(group) = self.find_group_of_player_mut(&msg.player_id) {
            // To avoid borrow checker issues, check session validity first, then get mutable reference
            let session_valid = {
                let player = group.get(&msg.player_id);
                player.map(|_p| is_matchmaking_session_addr_valid(group, &msg.player_id, &msg.addr)).unwrap_or(true)
            };
            if !session_valid {
                let player = group.get_mut(&msg.player_id).unwrap();
                player.addr.do_send(SessionKicked {
                    reason: "Another session has connected with your wallet.".to_string(),
                });
                player.addr = msg.addr.clone();
                debug!("[Matchmaking] Player {} reconnected in ready_groups (old session kicked)", msg.player_id);
                self.send_state();
            }
            return;
        }
        // If the player is already in the lobby, kick the old session and update their address.
        if self.lobby_players.contains_key(&msg.player_id) {
            // To avoid borrow checker issues, check session validity first, then get mutable reference
            let session_valid = {
                let player = self.lobby_players.get(&msg.player_id);
                player.map(|_p| is_matchmaking_session_addr_valid(&self.lobby_players, &msg.player_id, &msg.addr)).unwrap_or(true)
            };
            if !session_valid {
                let player = self.lobby_players.get_mut(&msg.player_id).unwrap();
                player.addr.do_send(SessionKicked {
                    reason: "Another session has connected with your wallet.".to_string(),
                });
                player.addr = msg.addr.clone();
                debug!("[Matchmaking] Player {} reconnected in lobby_players (old session kicked)", msg.player_id);
                self.send_state();
            }
            return;
        }
        // Otherwise, add as a new player in the lobby.
        self.add_or_update_lobby_player(msg.player_id.clone(), msg.addr, msg.username);
        debug!("[Matchmaking] Player {} joined lobby_players", msg.player_id);
        self.send_state();
    }
}

impl Handler<Leave> for MatchmakingServer {
    type Result = ();

    /// Handles a player leaving the lobby or ready group.
    fn handle(&mut self, msg: Leave, _ctx: &mut Self::Context) -> Self::Result {
        // Remove from lobby if present and session matches.
        if let Some(_player) = self.lobby_players.get(&msg.player_id) {
            if is_matchmaking_session_addr_valid(&self.lobby_players, &msg.player_id, &msg.addr) {
                self.lobby_players.remove(&msg.player_id);
                debug!("[Matchmaking] Player {} left lobby_players", msg.player_id);
                self.send_state();
                return;
            }
        }

        let countdown_active = self.countdown.is_some();
        // If in a ready group, handle leave logic.
        if let Some(group) = self.find_group_of_player_mut(&msg.player_id) {
            if let Some(_player) = group.get(&msg.player_id) {
                if !is_matchmaking_session_addr_valid(group, &msg.player_id, &msg.addr) {
                    // Not the same session, ignore.
                    return;
                }
            }
            
            if countdown_active {
                // Players cannot leave during countdown (game is about to start).
                debug!("[Matchmaking] Player {} tried to leave during countdown (not allowed)", msg.player_id);
                // TODO: send error message to client if needed.
                return;
            }
            
            group.remove(&msg.player_id);
            debug!("[Matchmaking] Player {} left ready_groups (removed, not put back in lobby)", msg.player_id);
            // Remove empty groups.
            self.ready_groups.retain(|g| !g.is_empty());
            self.refund_player(&msg.player_id);
            self.send_state();
            return;
        }
    }
}

impl Handler<Pay> for MatchmakingServer {
    type Result = ();

    /// Handles a player paying to become ready.
    fn handle(&mut self, msg: Pay, ctx: &mut Self::Context) -> Self::Result {
        // If already in a ready group, ignore (cannot pay twice).
        if let Some(group) = self.find_group_of_player_mut(&msg.player_id) {
            if let Some(_player) = group.get(&msg.player_id) {
                if is_matchmaking_session_addr_valid(group, &msg.player_id, &msg.addr) {
                    debug!("[Matchmaking] Player {} tried to pay but is already ready (same session)", msg.player_id);
                    // TODO: send error message to client if needed.
                    return;
                }
            }
        }
        
        // Remove from lobby; only if session matches.
        if let Some(_player) = self.lobby_players.get(&msg.player_id) {
            if !is_matchmaking_session_addr_valid(&self.lobby_players, &msg.player_id, &msg.addr) {
                debug!("[Matchmaking] Player {} tried to pay but session mismatch", msg.player_id);
                // TODO: send error message to client if needed.
                return;
            }
        } else {
            debug!("[Matchmaking] Player {} tried to pay but is not in lobby_players", msg.player_id);
            // TODO: send error message to client if needed.
            return;
        }
        
        let player = self.lobby_players.remove(&msg.player_id).unwrap();

        // Try to add to an existing group with space.
        let mut added_to_group = false;
        for group in &mut self.ready_groups {
            if group.len() < MAX_PLAYERS {
                group.insert(msg.player_id.clone(), player.clone());
                added_to_group = true;
                break;
            }
        }
        // If no group has space, create a new group.
        if !added_to_group {
            let mut new_group = HashMap::new();
            new_group.insert(msg.player_id.clone(), player.clone());
            self.ready_groups.push(new_group);
        }

        debug!("[Matchmaking] Player {} moved to ready_groups", msg.player_id);

        // If the first group is full, launch the game immediately.
        if let Some(first_group) = self.ready_groups.first() {
            if first_group.len() >= MAX_PLAYERS {
                self.cancel_countdown(ctx);
                self.try_launch_next_game(ctx);
            } else if first_group.len() >= MIN_PLAYERS && self.countdown.is_none() {
                // If enough players for a game, but not full, start countdown.
                self.start_countdown(ctx);
            }
        }
        self.send_state();
    }
}

impl Handler<CancelPayment> for MatchmakingServer {
    type Result = ();

    /// Handles a player cancelling payment and returning to the lobby.
    fn handle(&mut self, msg: CancelPayment, _ctx: &mut Self::Context) -> Self::Result {
        let countdown_active = self.countdown.is_some();
        let group = self.find_group_of_player_mut(&msg.player_id);
        if group.is_none() {
            // Player is not in any ready group; nothing to do.
            return;
        }
        let group = group.unwrap();

        // Check if the session matches
        if let Some(_player) = group.get(&msg.player_id) {
            if !is_matchmaking_session_addr_valid(group, &msg.player_id, &msg.addr) {
                // Not the same session, ignore.
                return;
            }
        }

        if countdown_active {
            // Cannot cancel payment during countdown (game is about to start).
            if let Some(player) = group.get(&msg.player_id) {
                player.addr.do_send(ServerWsMessage::Error {
                    message: "Cannot cancel payment: game is about to start.".to_string(),
                });
            }
            return;
        }

        // Remove from ready group and put back in lobby.
        if let Some(player) = group.remove(&msg.player_id) {
            self.add_or_update_lobby_player(msg.player_id.clone(), player.addr, player.info.username);
            // Remove empty groups.
            self.ready_groups.retain(|g| !g.is_empty());
            self.refund_player(&msg.player_id);
            self.send_state();
        }
    }
}

backend/src/server/matchmaking/mod.rs:
/// Matchmaking module: handles lobby, player readiness, and game assignment.

pub mod server;
pub mod session;
pub mod messages;
pub mod types;
backend/src/server/matchmaking/messages.rs:
/// Messages exchanged between client and server in the matchmaking lobby.

use actix::prelude::*;
use serde::{Serialize, Deserialize};
use uuid::Uuid;

use super::types::PlayerInfo;

/// State of the matchmaking lobby, sent to clients.
#[derive(Serialize, Deserialize, Clone, Debug)]
pub struct MatchmakingState {
    /// Players connected but not yet ready.
    pub lobby_players: Vec<PlayerInfo>,
    /// Players who have paid and are ready to play.
    pub ready_players: Vec<PlayerInfo>,
    /// Whether a countdown is active for starting a game.
    pub countdown_active: bool,
    /// Remaining countdown time in seconds, if active.
    pub countdown_remaining: Option<u64>,
}

/// Messages sent from client to server over WebSocket.
#[derive(Serialize, Deserialize, Clone, Debug)]
#[serde(tag = "action", content = "data")]
pub enum ClientWsMessage {
    /// Player wants to pay and become ready.
    Pay,
    /// Player wants to cancel payment and return to lobby.
    CancelPayment,
    /// Ping (keepalive or latency check).
    Ping,
}

/// Message to notify that a session has been kicked (e.g., due to being replaced).
#[derive(Message)]
#[rtype(result = "()")]
pub struct SessionKicked {
    pub reason: String,
}


/// Messages sent from server to client over WebSocket.
#[derive(Message, Serialize, Deserialize, Clone, Debug)]
#[rtype(result = "()")]
#[serde(tag = "action", content = "data")]
pub enum ServerWsMessage {
    /// Update the current state of the lobby.
    UpdateState(MatchmakingState),
    /// Notify the client that a game has started, with the assigned game ID.
    GameStarted {
        game_id: Uuid,
    },
    /// Notify the client of an error.
    Error {
        message: String,
    },
    /// Notify the client that their session has been kicked.
    SessionKicked {
        reason: String,
    },
}


backend/src/server/game_session/session.rs:
//! WebSocket session handler for a player or spectator in a game session.
//!
//! This actor manages a single WebSocket connection to a game session, handling
//! incoming client messages (actions, votes) and relaying server updates.

use actix::{Addr, Actor, StreamHandler, Handler, ActorContext};
use actix_web::{HttpRequest, HttpResponse, web, Error};
use actix_web_actors::ws;
use uuid::Uuid;
use log::{info, warn, error, debug};
use actix::AsyncContext;
use serde_json::json;
use crate::server::ws_actor_utils::WsActorUtils;

use crate::server::game_session::server::{GameSession, UnregisterSession, RegisterSession};
use crate::server::game_session::messages::{
    GamePreGameData, GameModeChosen, ProcessClientMessage, GameStateUpdate, PlayerAction,
    GameWsMessage, EnsureGameSession, GameModeVoteUpdate, GameClientWsMessage, GameModeVote,
    SessionKicked, SendWsTextMessage
};
use crate::server::matchmaking::types::WalletAddress;
use crate::server::ws_error::{http_error_response, ws_session_kicked_message};
use crate::server::anti_spam::AntiSpamState;

/// Represents a WebSocket session for a player or spectator in a game.
pub struct GameSessionActor {
    pub game_id: Uuid,
    pub player_id: WalletAddress,
    pub is_player: bool,
    pub session_addr: Addr<GameSession>,
    pub anti_spam: AntiSpamState,
}

impl Actor for GameSessionActor {
    type Context = ws::WebsocketContext<Self>;

    fn started(&mut self, ctx: &mut Self::Context) {
        // Register this session with the GameSession actor.
        self.session_addr.do_send(RegisterSession {
            wallet: self.player_id.clone(),
            addr: ctx.address(),
            is_player: self.is_player,
        });
    }

    fn stopped(&mut self, ctx: &mut Self::Context) {
        // Unregister this session from the GameSession actor.
        self.session_addr.do_send(UnregisterSession {
            wallet: self.player_id.clone(),
            is_player: self.is_player,
            addr: ctx.address(),
        });
    }
}

impl WsActorUtils for GameSessionActor {
    fn anti_spam(&mut self) -> &mut AntiSpamState {
        &mut self.anti_spam
    }
    
    fn player_id(&self) -> &str {
        &self.player_id
    }
}

impl GameSessionActor {
    /// Checks if the session is a player (not a spectator).
    /// If not, sends an error and returns false.
    fn ensure_is_player(&mut self, ctx: &mut ws::WebsocketContext<Self>) -> bool {
        if !self.is_player {
            warn!(
                "[WS] Command attempt by spectator: wallet={}",
                self.player_id
            );
            self.send_error_and_maybe_ban(
                ctx,
                "SPECTATOR_COMMAND",
                "Spectators cannot send commands",
                Some(json!(self.player_id)),
            );
            return false;
        }
        true
    }

    /// Sends an explicit error to the client and logs the reason.
    fn send_explicit_error(&mut self, ctx: &mut ws::WebsocketContext<Self>, code: &str, message: &str) {
        warn!("[WS] Error for wallet={}: {}", self.player_id, message);
        self.send_error_and_maybe_ban(ctx, code, message, Some(json!(self.player_id)));
    }
}

impl StreamHandler<Result<ws::Message, ws::ProtocolError>> for GameSessionActor {
    fn handle(&mut self, msg: Result<ws::Message, ws::ProtocolError>, ctx: &mut Self::Context) {
        // Anti-spam: record request, close if banned
        let player_id = self.player_id().to_string();
        if self.anti_spam().record_request(&player_id) {
            self.send_ban_and_close(ctx);
            return;
        }

        match msg {
            Ok(ws::Message::Text(ref text)) => {
                info!(
                    "[WS] Message received from wallet={} (is_player={}): {}",
                    self.player_id, self.is_player, text
                );
                // Only allow players (not spectators) to send commands.
                if !self.ensure_is_player(ctx) {
                    return;
                }
                debug!(
                    "[WS] Attempting to parse client message for wallet={}: {}",
                    self.player_id, text
                );
                // Parse the client message as JSON.
                let msg: GameClientWsMessage = match serde_json::from_str(text) {
                    Ok(m) => m,
                    Err(e) => {
                        self.send_explicit_error(
                            ctx,
                            "INVALID_ACTION",
                            &format!("Invalid command format: {}", e),
                        );
                        return;
                    }
                };
                debug!(
                    "[WS] Successfully parsed client message for wallet={}: {:?}",
                    self.player_id, msg
                );
                // Handle the parsed client message.
                match msg {
                    GameClientWsMessage::Move(dir) => {
                        self.session_addr.do_send(ProcessClientMessage {
                            msg: PlayerAction::Move(dir),
                            player_id: self.player_id.clone(),
                            addr: ctx.address(),
                        });
                        self.anti_spam.reset_on_valid_action();
                    }
                    GameClientWsMessage::Shoot { x, y } => {
                        self.session_addr.do_send(ProcessClientMessage {
                            msg: PlayerAction::Shoot { x, y },
                            player_id: self.player_id.clone(),
                            addr: ctx.address(),
                        });
                        self.anti_spam.reset_on_valid_action();
                    }
                    GameClientWsMessage::GameModeVote { mode } => {
                        // Forward the mode vote to the session.
                        self.session_addr.do_send(GameModeVote {
                            player_id: self.player_id.clone(),
                            mode,
                        });
                        self.anti_spam.reset_on_valid_action();
                    }
                    // Add other variants here if needed.
                }
            }
            Ok(ws::Message::Ping(msg)) => ctx.pong(&msg),
            Ok(ws::Message::Close(_)) => {
                info!("[WS] Connection closed: wallet={}", self.player_id);
                ctx.stop();
            }
            Ok(other) => {
                debug!("[WS] Ignored WebSocket message: {:?}", other);
            }
            Err(e) => {
                error!("[WS] WebSocket error: wallet={} err={:?}", self.player_id, e);
                self.send_explicit_error(
                    ctx,
                    "WS_PROTOCOL_ERROR",
                    &format!("WebSocket protocol error: {:?}", e),
                );
                ctx.stop();
            }
        }
    }
}

impl Handler<GamePreGameData> for GameSessionActor {
    type Result = ();

    fn handle(&mut self, msg: GamePreGameData, ctx: &mut Self::Context) -> Self::Result {
        let ws_msg = GameWsMessage::GamePreGameData(msg);
        match serde_json::to_string(&ws_msg) {
            Ok(text) => {
                self.send_json_or_ban(ctx, text);
            },
            Err(e) => self.send_explicit_error(
                ctx,
                "SERIALIZATION_ERROR",
                &format!("Failed to serialize available game modes: {}", e),
            ),
        }
    }
}

impl Handler<GameModeChosen> for GameSessionActor {
    type Result = ();

    fn handle(&mut self, msg: GameModeChosen, ctx: &mut Self::Context) -> Self::Result {
        let ws_msg = GameWsMessage::GameModeChosen(msg);
        match serde_json::to_string(&ws_msg) {
            Ok(text) => {
                self.send_json_or_ban(ctx, text);
            },
            Err(e) => self.send_explicit_error(
                ctx,
                "SERIALIZATION_ERROR",
                &format!("Failed to serialize chosen mode: {}", e),
            ),
        }
    }
}

impl Handler<GameModeVoteUpdate> for GameSessionActor {
    type Result = ();

    fn handle(&mut self, msg: GameModeVoteUpdate, ctx: &mut Self::Context) -> Self::Result {
        let ws_msg = GameWsMessage::GameModeVoteUpdate(msg);
        match serde_json::to_string(&ws_msg) {
            Ok(text) => {
                self.send_json_or_ban(ctx, text);
            },
            Err(e) => self.send_explicit_error(
                ctx,
                "SERIALIZATION_ERROR",
                &format!("Failed to serialize vote update: {}", e),
            ),
        }
    }
}

impl Handler<GameStateUpdate> for GameSessionActor {
    type Result = ();

    fn handle(&mut self, msg: GameStateUpdate, ctx: &mut Self::Context) -> Self::Result {
        debug!(
            "[WS] Sending GameStateUpdate to wallet={} (is_player={}): turn={} players={:?} turn_duration={}",
            self.player_id,
            self.is_player,
            msg.state.turn,
            msg.state.players.iter().map(|p| (p.id.clone(), p.pos, p.is_alive)).collect::<Vec<_>>(),
            msg.turn_duration
        );
        let ws_msg = GameWsMessage::GameStateUpdate { state: msg.state, turn_duration: msg.turn_duration };
        match serde_json::to_string(&ws_msg) {
            Ok(text) => {
                // Reset error suppression at each turn (new state)
                self.anti_spam().reset_error_suppression();
                
                self.send_json_or_ban(ctx, text);
            },
            Err(e) => {
                error!(
                    "[WS] Serialization error GameStateUpdate for wallet={}: {}",
                    self.player_id, e
                );
                self.send_explicit_error(
                    ctx,
                    "SERIALIZATION_ERROR",
                    &format!("Failed to serialize game state: {}", e),
                );
            }
        }
    }
}

impl Handler<SessionKicked> for GameSessionActor {
    type Result = ();

    fn handle(&mut self, _msg: SessionKicked, ctx: &mut Self::Context) -> Self::Result {
        info!("[WS] Session kicked: wallet={}", self.player_id);
        ctx.text(ws_session_kicked_message(Some(json!(self.player_id))));
        ctx.stop();
    }
}

impl Handler<SendWsTextMessage> for GameSessionActor {
    type Result = ();

    fn handle(&mut self, msg: SendWsTextMessage, ctx: &mut Self::Context) -> Self::Result {
        self.send_json_or_ban(ctx, msg.text);
    }
}

/// WebSocket endpoint for joining a game session.
/// Expects path parameter: `game_id` and query parameter: `wallet`.
pub async fn ws_game(
    req: HttpRequest,
    stream: web::Payload,
    data: web::Data<crate::server::state::AppState>,
) -> Result<HttpResponse, Error> {
    let game_id_str = req.match_info().get("game_id").unwrap().to_string();
    let game_id = match Uuid::parse_str(&game_id_str) {
        Ok(uuid) => uuid,
        Err(_) => {
            warn!("[WS] Invalid game_id received: {}", game_id_str);
            return Ok(http_error_response(
                "INVALID_GAME_ID",
                "Invalid game_id",
                Some(json!(game_id_str)),
                actix_web::http::StatusCode::BAD_REQUEST,
            ));
        }
    };

    // Extract wallet address from query parameters.
    let mut player_id: Option<WalletAddress> = None;
    for kv in req.query_string().split('&') {
        let mut split = kv.split('=');
        match (split.next(), split.next()) {
            (Some("wallet"), Some(addr)) => {
                player_id = Some(addr.to_string());
            }
            _ => {}
        }
    }
    let player_id = match player_id {
        Some(addr) if !addr.is_empty() => addr,
        _ => {
            warn!("[WS] Connection refused: missing wallet for game_id={}", game_id);
            return Ok(http_error_response(
                "MISSING_WALLET",
                "Missing wallet address",
                Some(json!(game_id.to_string())),
                actix_web::http::StatusCode::BAD_REQUEST,
            ));
        }
    };

    // Ensure the game session exists or create it.
    let session_addr = match data
        .game_session_manager
        .send(EnsureGameSession {
            game_id,
            mode: None,
        })
        .await
    {
        Ok(Ok(addr)) => addr,
        Ok(Err(e)) => {
            error!(
                "[WS] Failed to ensure game session for game_id={}: {}",
                game_id, e
            );
            return Ok(http_error_response(
                "GAME_SESSION_ERROR",
                &e,
                Some(json!(game_id.to_string())),
                actix_web::http::StatusCode::INTERNAL_SERVER_ERROR,
            ));
        }
        Err(e) => {
            error!(
                "[WS] Mailbox error when ensuring game session for game_id={}: {}",
                game_id, e
            );
            return Ok(http_error_response(
                "MAILBOX_ERROR",
                "Internal server error",
                Some(json!(game_id.to_string())),
                actix_web::http::StatusCode::INTERNAL_SERVER_ERROR,
            ));
        }
    };

    ws::start(
        GameSessionActor {
            game_id,
            player_id: player_id.clone(),
            is_player: true, // TODO: handle spectators if needed
            session_addr,
            anti_spam: AntiSpamState::new(),
        },
        &req,
        stream,
    )
}

backend/src/server/game_session/turn_resolution.rs:
/// Handles turn start and resolution logic for GameSession.
/// Encapsulates timer management, action collection, and state updates.

use std::time::{Duration, Instant};
use actix::prelude::*;

use crate::server::game_session::server::GameSession;
use crate::server::game_session::messages::GameStateUpdate;
use crate::config::game::TURN_DURATION;

/// Start a new turn: reset actions, launch timer, broadcast state.
pub fn start_new_turn(this: &mut GameSession, ctx: &mut Context<GameSession>) {
    if this.game_state.is_none() {
        return;
    }
    this.turn_in_progress = true;
    this.pending_actions.clear();
    this.turn_start_time = Some(Instant::now());

    // Start the turn timer.
    let handle = ctx.run_later(Duration::from_secs(TURN_DURATION), |act, ctx| {
        resolve_turn(act, ctx);
    });
    this.turn_timer = Some(handle);

    // Broadcast the new turn state.
    if let Some(ref state) = this.game_state {
        let turn_duration = this.get_turn_remaining_secs();
        for addr in this.players.values().chain(this.spectators.values()) {
            addr.do_send(GameStateUpdate { state: state.clone(), turn_duration });
        }
    }
}

/// Resolve the current turn: apply actions, update state, check for game end.
pub fn resolve_turn(this: &mut GameSession, ctx: &mut Context<GameSession>) {
    if this.game_state.is_none() || !this.turn_in_progress {
        return;
    }
    this.turn_in_progress = false;

    let state = this.game_state.as_mut().unwrap();

    // For each living player, if no action was received, default to Stay.
    for info in &this.player_infos {
        if !this.pending_actions.contains_key(&info.id) {
            if let Some(_idx) = state.players.iter().position(|p| p.username == info.username && p.is_alive) {
                this.pending_actions.insert(info.id.clone(), crate::server::game_session::messages::PlayerAction::Move(crate::game::types::Direction::Stay));
            }
        }
    }

    // Apply all actions in player order.
    for (i, info) in this.player_infos.iter().enumerate() {
        if let Some(player) = state.players.get(i) {
            if !player.is_alive { continue; }
        }
        if let Some(action) = this.pending_actions.get(&info.id) {
            state.apply_player_action(action.clone(), i);
        }
    }

    // Advance the turn counter.
    state.next_turn();

    // If more than one player is alive, start the next turn.
    if state.players.iter().filter(|p| p.is_alive).count() > 1 {
        start_new_turn(this, ctx);
    } else {
        // Game is over, notify all clients.
        for addr in this.players.values().chain(this.spectators.values()) {
            addr.do_send(GameStateUpdate { state: state.clone(), turn_duration: 0 });
            // TODO: send a GameEnded message if needed
        }
    }
}

backend/src/server/game_session/server.rs:
//! Game session management and orchestration.
//!
//! This module defines the actors responsible for managing game sessions, including
//! player registration, game state progression, mode voting, and turn resolution.

use actix::prelude::*;
use std::collections::HashMap;
use std::time::{Duration, Instant};
use uuid::Uuid;
use log::{info, warn, debug};
use serde_json::json;

use crate::game::state::GameState;
use crate::server::matchmaking::types::{PlayerInfo, WalletAddress};
use crate::server::game_session::session::GameSessionActor;
use crate::config::game::{TURN_DURATION, GRID_ROW, GRID_COL};
use crate::server::session_utils::{is_game_session_addr_valid, is_game_session_spectator_addr_valid};
use crate::game::types::GameMode;
use crate::server::game_session::messages::{
    GameStateUpdate, ProcessClientMessage, PlayerAction, RegisterPendingGame, EnsureGameSession,
    GameModeVote, SessionKicked, SendWsTextMessage
};
use crate::server::ws_error::ws_error_message;
use crate::server::game_session::mode_choice::ModeChoice;
use crate::server::game_session::turn_resolution::{start_new_turn, resolve_turn};

/// Stores pending games waiting for session creation.
pub struct PendingGames {
    pub pending: HashMap<Uuid, Vec<PlayerInfo>>,
}

impl PendingGames {
    pub fn new() -> Self {
        Self { pending: HashMap::new() }
    }
    pub fn insert(&mut self, game_id: Uuid, players: Vec<PlayerInfo>) {
        self.pending.insert(game_id, players);
    }
    pub fn take(&mut self, game_id: &Uuid) -> Option<Vec<PlayerInfo>> {
        self.pending.remove(game_id)
    }
    pub fn contains(&self, game_id: &Uuid) -> bool {
        self.pending.contains_key(game_id)
    }
}

/// Manages all game sessions and pending games.
pub struct GameSessionManager {
    sessions: HashMap<Uuid, Addr<GameSession>>,
    pending_games: HashMap<Uuid, Vec<PlayerInfo>>,
}

impl GameSessionManager {
    /// Create a new manager.
    pub fn new() -> Self {
        Self {
            sessions: HashMap::new(),
            pending_games: HashMap::new(),
        }
    }

    /// Register a pending game (called by matchmaking).
    pub fn register_pending_game(&mut self, game_id: Uuid, players: Vec<PlayerInfo>) {
        self.pending_games.insert(game_id, players);
    }

    /// Ensure a GameSession exists for the given game_id, creating it if needed.
    pub fn ensure_game_session(&mut self, game_id: Uuid) -> Result<Addr<GameSession>, String> {
        if let Some(addr) = self.sessions.get(&game_id) {
            // Session already exists, return it.
            return Ok(addr.clone());
        }
        // If not, check for pending players and create a new session.
        let players = self.pending_games.remove(&game_id)
            .ok_or_else(|| "No player group found for this game_id".to_string())?;
        let session = GameSession::new(game_id, players).start();
        self.sessions.insert(game_id, session.clone());
        Ok(session)
    }
}

impl Actor for GameSessionManager {
    type Context = Context<Self>;
}

impl Handler<RegisterPendingGame> for GameSessionManager {
    type Result = ();

    fn handle(&mut self, msg: RegisterPendingGame, _: &mut Context<Self>) -> Self::Result {
        self.register_pending_game(msg.game_id, msg.players);
    }
}

impl Handler<EnsureGameSession> for GameSessionManager {
    type Result = Result<Addr<GameSession>, String>;

    fn handle(&mut self, msg: EnsureGameSession, _: &mut Context<Self>) -> Self::Result {
        self.ensure_game_session(msg.game_id)
    }
}

/// Represents a running game session (one per game_id).
pub struct GameSession {
    pub game_id: Uuid,
    pub player_infos: Vec<PlayerInfo>,
    pub players: HashMap<WalletAddress, Addr<GameSessionActor>>,
    pub spectators: HashMap<WalletAddress, Addr<GameSessionActor>>,
    pub game_state: Option<GameState>,

    // Mode choice phase
    pub mode_choice: ModeChoice,

    // In-game phase
    pub pending_actions: HashMap<WalletAddress, PlayerAction>,
    pub turn_timer: Option<SpawnHandle>,
    pub turn_in_progress: bool,
    pub turn_start_time: Option<Instant>,
}

#[derive(Debug, Clone, PartialEq)]
enum GamePhase {
    WaitingForModeChoice,
    InGame,
}

impl GameSession {
    /// Create a new game session for the given players.
    pub fn new(game_id: Uuid, player_infos: Vec<PlayerInfo>) -> Self {
        let required_players = player_infos.len();
        Self {
            game_id,
            player_infos,
            players: HashMap::new(),
            spectators: HashMap::new(),
            game_state: None,
            mode_choice: ModeChoice::new(required_players),
            pending_actions: HashMap::new(),
            turn_timer: None,
            turn_in_progress: false,
            turn_start_time: None,
        }
    }
    

    /// Start the mode choice phase (used for restarts or new games).
    fn start_mode_choice(&mut self, ctx: &mut Context<Self>) {
        self.mode_choice.reset();
        self.mode_choice.broadcast_to_players_pre_game_data(
            &self.players,
            &self.spectators,
            &self.player_infos,
        );
        // Start the timer for mode choice deadline.
        let deadline_secs = self.mode_choice.deadline.saturating_duration_since(Instant::now()).as_secs();
        let handle = ctx.run_later(Duration::from_secs(deadline_secs), |act, ctx| {
            act.finalize_mode_choice(ctx);
        });
        self.mode_choice.timer = Some(handle);
        info!("[GameSession] Mode choice started for game_id={}", self.game_id);
    }

    /// Finalize the mode choice, either by votes or randomly if no votes.
    fn finalize_mode_choice(&mut self, ctx: &mut Context<Self>) {
        self.mode_choice.finalize_mode_choice(
            &self.player_infos,
            &self.players,
            &self.spectators,
        );
        // Initialize the game state with the chosen mode.
        let chosen_mode = self.mode_choice.chosen_mode.clone().expect("Mode should be chosen before broadcasting");
        self.game_state = Some(GameState::new(
            GRID_ROW, GRID_COL, self.player_infos.clone(), chosen_mode,
        ));
        // Cancel the mode choice timer if it was set.
        if let Some(handle) = self.mode_choice.timer.take() {
            ctx.cancel_future(handle);
        }
        self.turn_in_progress = false;
        self.turn_start_time = None;
        start_new_turn(self, ctx);
    }

    /// Register a mode vote from a player.
    fn receive_mode_vote(&mut self, player_id: WalletAddress, mode: GameMode, ctx: &mut Context<Self>) {
        let all_voted = self.mode_choice.receive_mode_vote(
            player_id,
            mode,
            &self.players,
            &self.spectators,
        );
        if all_voted {
            self.finalize_mode_choice(ctx);
        }
    }

    /// Broadcast the current game state to all players and spectators.
    pub fn send_state(&self) {
        if let Some(ref state) = self.game_state {
            let turn_duration = self.get_turn_remaining_secs();
            debug!(
                "[GameSession] Broadcast GameState: game_id={} turn={} players={:?} turn_remaining={}",
                self.game_id,
                state.turn,
                state.players.iter().map(|p| &p.id).collect::<Vec<_>>(),
                turn_duration
            );
            for addr in self.players.values().chain(self.spectators.values()) {
                addr.do_send(GameStateUpdate { state: state.clone(), turn_duration });
            }
        }
    }

    /// Calculate the actual remaining time for the current turn (in seconds).
    pub fn get_turn_remaining_secs(&self) -> u64 {
        if self.turn_in_progress {
            if let Some(start) = self.turn_start_time {
                let elapsed = Instant::now().saturating_duration_since(start).as_secs();
                if elapsed >= TURN_DURATION {
                    0
                } else {
                    TURN_DURATION - elapsed
                }
            } else {
                TURN_DURATION
            }
        } else {
            TURN_DURATION
        }
    }
}

impl Actor for GameSession {
    type Context = Context<Self>;

    fn started(&mut self, ctx: &mut Self::Context) {
        // On actor start, broadcast pre-game data if in mode choice phase.
        if self.game_state.is_none() {
            self.start_mode_choice(ctx);
        }
    }
}

/// Message to get a GameSession by game_id.
#[derive(Message)]
#[rtype(result = "Result<Addr<GameSession>, String>")]
pub struct GetGameSession {
    pub game_id: Uuid,
}

// Handler for GameModeVote: notifies all players of the vote and finalizes if all have voted.
impl Handler<GameModeVote> for GameSession {
    type Result = ();

    fn handle(&mut self, msg: GameModeVote, ctx: &mut Context<Self>) -> Self::Result {
        self.receive_mode_vote(msg.player_id, msg.mode, ctx);
    }
}

impl Handler<GetGameSession> for GameSessionManager {
    type Result = Result<Addr<GameSession>, String>;

    fn handle(&mut self, msg: GetGameSession, _: &mut Context<Self>) -> Self::Result {
        self.sessions.get(&msg.game_id)
            .cloned()
            .ok_or_else(|| "Game session not found".to_string())
    }
}

/// Message to check if a player is in a game.
#[derive(Message)]
#[rtype(result = "Result<bool, String>")]
pub struct IsPlayerInGame {
    pub game_id: Uuid,
    pub player_id: WalletAddress,
}

impl Handler<IsPlayerInGame> for GameSessionManager {
    type Result = Result<bool, String>;

    fn handle(&mut self, msg: IsPlayerInGame, _: &mut Context<Self>) -> Self::Result {
        self.sessions.get(&msg.game_id)
            .map(|session_addr| {
                session_addr.try_send(IsPlayer(msg.player_id.clone()))
                    .map(|_| true)
                    .unwrap_or(false)
            })
            .ok_or_else(|| "Game session not found".to_string())
    }
}

/// Message to check if a wallet is a player in the session.
#[derive(Message)]
#[rtype(result = "bool")]
pub struct IsPlayer(pub WalletAddress);

impl Handler<IsPlayer> for GameSession {
    type Result = bool;

    fn handle(&mut self, msg: IsPlayer, _: &mut Context<Self>) -> Self::Result {
        self.player_infos.iter().any(|p| p.id == msg.0)
    }
}

impl Handler<ProcessClientMessage> for GameSession {
    type Result = ();

    fn handle(&mut self, msg: ProcessClientMessage, ctx: &mut Context<Self>) -> Self::Result {
        // Verify that the session address matches the one registered for this wallet
        if !is_game_session_addr_valid(&self.players, &msg.player_id, &msg.addr) {
            warn!("[GameSession] Action ignored: session addr mismatch for wallet={}", msg.player_id);
            msg.addr.do_send(SendWsTextMessage {
                text: ws_error_message(
                    "SESSION_ADDR_MISMATCH",
                    "Session address mismatch: your session is not recognized for this game.",
                    Some(json!(msg.player_id)),
                ),
            });
            return;
        }

        // Ignore actions if the game hasn't started.
        if self.game_state.is_none() {
            msg.addr.do_send(SendWsTextMessage {
                text: ws_error_message(
                    "GAME_NOT_STARTED",
                    "Game has not started yet. You cannot act now.",
                    Some(json!(msg.player_id)),
                ),
            });
            return;
        }
        // Ignore actions if the turn is not in progress.
        if !self.turn_in_progress {
            warn!("[GameSession] Action received while turn is not in progress");
            msg.addr.do_send(SendWsTextMessage {
                text: ws_error_message(
                    "TURN_NOT_IN_PROGRESS",
                    "Turn is not in progress. Please wait for your turn.",
                    Some(json!(msg.player_id)),
                ),
            });
            return;
        }

        // Find the player's index.
        let player_index = match self.player_infos.iter().position(|p| p.id == msg.player_id) {
            Some(idx) => idx,
            None => {
                msg.addr.do_send(SendWsTextMessage {
                    text: ws_error_message(
                        "UNKNOWN_PLAYER",
                        "Unknown player: you are not part of this game.",
                        Some(json!(msg.player_id)),
                    ),
                });
                return;
            }
        };

        // Only allow actions from living players.
        if !self.game_state.as_ref().unwrap().players.get(player_index).map(|p| p.is_alive).unwrap_or(false) {
            warn!("[GameSession] Dead or unknown player tried to act: {}", msg.player_id);
            msg.addr.do_send(SendWsTextMessage {
                text: ws_error_message(
                    "PLAYER_ELIMINATED",
                    "You are eliminated and cannot act anymore.",
                    Some(json!(msg.player_id)),
                ),
            });
            return;
        }

        // Prevent multiple actions per turn.
        if self.pending_actions.contains_key(&msg.player_id) {
            warn!("[GameSession] Player {} spamming, action already received this turn", msg.player_id);
            msg.addr.do_send(SendWsTextMessage {
                text: ws_error_message(
                    "ALREADY_ACTED",
                    "You have already acted this turn. Please wait for the next turn.",
                    Some(json!(msg.player_id)),
                ),
            });
            return;
        }

        // Register the action.
        self.pending_actions.insert(msg.player_id.clone(), msg.msg);

        // If all living players have acted, resolve the turn immediately.
        let alive_count = self.game_state.as_ref().unwrap().players.iter().filter(|p| p.is_alive).count();
        if self.pending_actions.len() >= alive_count {
            // Cancel the timer and resolve the turn.
            if let Some(handle) = self.turn_timer.take() {
                ctx.cancel_future(handle);
            }
            resolve_turn(self, ctx);
        }
    }
}

/// Message to register a session (player or spectator).
#[derive(Message)]
#[rtype(result = "()")]
pub struct RegisterSession {
    pub wallet: WalletAddress,
    pub addr: Addr<GameSessionActor>,
    pub is_player: bool,
}

/// Message to unregister a session (player or spectator).
#[derive(Message)]
#[rtype(result = "()")]
pub struct UnregisterSession {
    pub wallet: WalletAddress,
    pub addr: Addr<GameSessionActor>,
    pub is_player: bool,
}

impl Handler<RegisterSession> for GameSession {
    type Result = ();

    fn handle(&mut self, msg: RegisterSession, _: &mut Context<Self>) -> Self::Result {
        if msg.is_player {
            // Only kick if the address is different (unicity)
            if let Some(old_addr) = self.players.get(&msg.wallet) {
                if !is_game_session_addr_valid(&self.players, &msg.wallet, &msg.addr) {
                    old_addr.do_send(SessionKicked {
                        reason: "Another session has connected with your wallet in this game.".to_string(),
                    });
                    self.players.insert(msg.wallet.clone(), msg.addr.clone());
                }
                // else: already registered, nothing to do
            } else {
                self.players.insert(msg.wallet.clone(), msg.addr.clone());
            }
        } else {
            // Same logic for spectators
            if let Some(old_addr) = self.spectators.get(&msg.wallet) {
                if !is_game_session_spectator_addr_valid(&self.spectators, &msg.wallet, &msg.addr) {
                    old_addr.do_send(SessionKicked {
                        reason: "Another session has connected with your wallet in this game (spectator).".to_string(),
                    });
                    self.spectators.insert(msg.wallet.clone(), msg.addr.clone());
                }
                // else: already registered, nothing to do
            } else {
                self.spectators.insert(msg.wallet.clone(), msg.addr.clone());
            }
        }

        if self.game_state.is_none() {
            self.mode_choice.broadcast_to_players_pre_game_data(
                &self.players,
                &self.spectators,
                &self.player_infos,
            );
        } else {
            if let Some(ref state) = self.game_state {
                // Use the real remaining time, not TURN_DURATION
                let turn_duration = self.get_turn_remaining_secs();
                msg.addr.do_send(GameStateUpdate { state: state.clone(), turn_duration });
            }
        }
    }
}

impl Handler<UnregisterSession> for GameSession {
    type Result = ();

    fn handle(&mut self, msg: UnregisterSession, _: &mut Context<Self>) -> Self::Result {
        if msg.is_player {
            // Only remove the player if the address matches the registered one
            if is_game_session_addr_valid(&self.players, &msg.wallet, &msg.addr) {
                self.players.remove(&msg.wallet);
            } else {
                warn!("[GameSession] Unregister ignored: session addr mismatch for wallet={}", msg.wallet);
            }
        } else {
            // For spectators, apply the same verification
            if is_game_session_spectator_addr_valid(&self.spectators, &msg.wallet, &msg.addr) {
                self.spectators.remove(&msg.wallet);
            } else {
                warn!("[GameSession] Spectator unregister ignored: session addr mismatch for wallet={}", msg.wallet);
            }
        }
    }
}

backend/src/server/game_session/mod.rs:
pub mod server;
pub mod session;
pub mod messages;
pub mod mode_choice;
pub mod turn_resolution;

pub use server::GameSession;
backend/src/server/game_session/mode_choice.rs:
/// Handles the game mode choice phase for a GameSession.
/// Encapsulates voting, broadcasting pre-game data, and finalization logic.

use std::collections::HashMap;
use std::time::{Duration, Instant};
use actix::prelude::*;
use rand::prelude::IteratorRandom;
use log::info;

use crate::game::types::GameMode;
use crate::server::matchmaking::types::{PlayerInfo, WalletAddress};
use crate::server::game_session::messages::{
    GamePreGameData, GameModeVoteUpdate, GameModeChosen,
};
use crate::config::game::{MODE_CHOICE_DURATION, GRID_ROW, GRID_COL};
use crate::server::game_session::session::GameSessionActor;

/// Represents the state and logic for the mode choice phase.
pub struct ModeChoice {
    pub votes: HashMap<WalletAddress, GameMode>,
    pub deadline: Instant,
    pub timer: Option<SpawnHandle>,
    pub chosen_mode: Option<GameMode>,
    pub chosen_by: Option<WalletAddress>,
    pub required_players: usize,
}

impl ModeChoice {
    /// Create a new ModeChoice phase for the given number of players.
    pub fn new(required_players: usize) -> Self {
        Self {
            votes: HashMap::new(),
            deadline: Instant::now() + Duration::from_secs(MODE_CHOICE_DURATION),
            timer: None,
            chosen_mode: None,
            chosen_by: None,
            required_players,
        }
    }

    /// Broadcast pre-game data (available modes, deadline, players, grid size) to all sessions.
    pub fn broadcast_to_players_pre_game_data(
        &self,
        players: &std::collections::HashMap<WalletAddress, Addr<GameSessionActor>>,
        spectators: &std::collections::HashMap<WalletAddress, Addr<GameSessionActor>>,
        player_infos: &[PlayerInfo],
    ) {
        let deadline_secs = self.deadline.saturating_duration_since(Instant::now()).as_secs();
        let msg = GamePreGameData {
            modes: vec![GameMode::Classic, GameMode::Cracked],
            deadline_secs,
            players: player_infos.to_vec(),
            grid_row: GRID_ROW,
            grid_col: GRID_COL,
        };
        for addr in players.values().chain(spectators.values()) {
            addr.do_send(msg.clone());
        }
    }

    /// Register a mode vote from a player and broadcast the update.
    pub fn receive_mode_vote(
        &mut self,
        player_id: WalletAddress,
        mode: GameMode,
        players: &std::collections::HashMap<WalletAddress, Addr<GameSessionActor>>,
        spectators: &std::collections::HashMap<WalletAddress, Addr<GameSessionActor>>,
    ) -> bool {
        self.votes.insert(player_id.clone(), mode.clone());
        let vote_update = GameModeVoteUpdate {
            player_id,
            mode,
        };
        for addr in players.values().chain(spectators.values()) {
            addr.do_send(vote_update.clone());
        }
        // Return true if all players have voted.
        self.votes.len() >= self.required_players
    }

    /// Finalize the mode choice, picking randomly if needed.
    pub fn finalize_mode_choice(
        &mut self,
        player_infos: &[PlayerInfo],
        players: &std::collections::HashMap<WalletAddress, Addr<GameSessionActor>>,
        spectators: &std::collections::HashMap<WalletAddress, Addr<GameSessionActor>>,
    ) {
        let (chosen_mode, chosen_by) = if !self.votes.is_empty() {
            let mut rng = rand::rng();
            let (chosen_player, mode) = self.votes.iter().choose(&mut rng).unwrap();
            (mode.clone(), chosen_player.clone())
        } else {
            let modes = [GameMode::Classic, GameMode::Cracked];
            let mut rng = rand::rng();
            let mode = *modes.iter().choose(&mut rng).unwrap();
            let chosen_player = player_infos.iter().choose(&mut rng).unwrap().id.clone();
            (mode, chosen_player)
        };
        self.chosen_mode = Some(chosen_mode.clone());
        self.chosen_by = Some(chosen_by.clone());
        for addr in players.values().chain(spectators.values()) {
            addr.do_send(GameModeChosen {
                mode: chosen_mode.clone(),
                chosen_by: chosen_by.clone(),
            });
        }
        info!("[ModeChoice] Mode chosen: {:?} by {}", chosen_mode, chosen_by);
    }

    /// Reset the mode choice phase (for restarts).
    pub fn reset(&mut self) {
        self.votes.clear();
        self.chosen_mode = None;
        self.chosen_by = None;
        self.deadline = Instant::now() + Duration::from_secs(MODE_CHOICE_DURATION);
        self.timer = None;
    }
}
backend/src/server/game_session/messages.rs:
//! Messages and types for game session actors and WebSocket protocol.
//!
//! Defines all messages exchanged between the game session actors, as well as the protocol
//! for client-server communication during a game.

use actix::prelude::*;
use serde::{Serialize, Deserialize};
use actix::Addr;
use uuid::Uuid;

use super::session::GameSessionActor;
use crate::game::types::{Direction, GameMode};
use crate::game::state::GameState;
use crate::server::matchmaking::types::{WalletAddress, PlayerInfo};
use crate::server::game_session::GameSession;

/// Message to register a pending game (sent by matchmaking when a group is ready).
#[derive(Message)]
#[rtype(result = "()")]
pub struct RegisterPendingGame {
    pub game_id: Uuid,
    pub players: Vec<PlayerInfo>,
}

/// Message to request creation or retrieval of a GameSession for a given game_id.
/// Used when a client connects to a game WebSocket.
#[derive(Message)]
#[rtype(result = "Result<Addr<GameSession>, String>")]
pub struct EnsureGameSession {
    pub game_id: Uuid,
    pub mode: Option<GameMode>,
}

/// Message sent by a player to perform an action (move or shoot).
#[derive(Message)]
#[rtype(result = "()")]
pub struct ProcessClientMessage {
    pub msg: PlayerAction,
    pub player_id: WalletAddress,
    pub addr: Addr<GameSessionActor>,
}

/// Player action sent by the client (move or shoot).
#[derive(Serialize, Deserialize, Debug, Clone)]
pub enum PlayerAction {
    Move(Direction),
    Shoot { x: usize, y: usize },
}

/// WebSocket messages sent from client to server during a game session.
#[derive(Serialize, Deserialize, Debug, Clone)]
#[serde(tag = "action", content = "data")]
pub enum GameClientWsMessage {
    /// Move in a direction.
    Move(Direction),
    /// Shoot at a tile.
    Shoot { x: usize, y: usize },
    /// Vote for a game mode.
    GameModeVote { mode: GameMode },
}

/// Message sent when a player votes for a game mode.
#[derive(Message)]
#[rtype(result = "()")]
pub struct GameModeVote {
    pub player_id: WalletAddress,
    pub mode: GameMode,
}

/// Data sent to all players at the start of the game or when the pre-game phase is refreshed.
#[derive(Message, Clone, Serialize, Deserialize, Debug)]
#[rtype(result = "()")]
pub struct GamePreGameData {
    pub modes: Vec<GameMode>,
    pub deadline_secs: u64,
    pub players: Vec<PlayerInfo>,
    pub grid_row: usize,
    pub grid_col: usize,
}

/// Notification sent to all players when a player votes for a mode.
#[derive(Message, Clone, Serialize, Deserialize, Debug)]
#[rtype(result = "()")]
pub struct GameModeVoteUpdate {
    pub player_id: WalletAddress,
    pub mode: GameMode,
}

/// Notification of the chosen mode and the player who was selected to decide.
#[derive(Message, Clone, Serialize, Deserialize, Debug)]
#[rtype(result = "()")]
pub struct GameModeChosen {
    pub mode: GameMode,
    pub chosen_by: WalletAddress,
}

/// Game state update sent to all players after each turn.
#[derive(Message, Clone, Serialize, Deserialize, Debug)]
#[rtype(result = "()")]
pub struct GameStateUpdate {
    pub state: GameState,
    pub turn_duration: u64,
}

/// Message to kick a session (unicity violation).
#[derive(Message)]
#[rtype(result = "()")]
pub struct SessionKicked {
    pub reason: String,
}

/// Message to unregister a session (player or spectator).
#[derive(Message)]
#[rtype(result = "()")]
pub struct UnregisterSession {
    pub wallet: WalletAddress,
    pub is_player: bool,
    pub addr: Addr<GameSessionActor>,
}

/// Utility message to send arbitrary text over WebSocket.
/// Used for custom errors or notifications.
#[derive(Message)]
#[rtype(result = "()")]
pub struct SendWsTextMessage {
    pub text: String,
}

/// WebSocket messages sent from server to client during a game session.
#[derive(Message, Serialize, Deserialize, Clone, Debug)]
#[rtype(result = "()")]
#[serde(tag = "action", content = "data")]
pub enum GameWsMessage {
    /// Initial game state and mode.
    GameInit { state: GameState, mode: GameMode },
    /// Game state update after a turn.
    GameStateUpdate { state: GameState, turn_duration: u64 },
    /// Game ended, with winner.
    GameEnded { winner: String },
    /// Error message.
    Error { message: String },
    /// Session kicked notification.
    SessionKicked { reason: String },
    /// Pre-game data (mode choice, players, deadline).
    GamePreGameData(GamePreGameData),
    /// Notification of a mode vote.
    GameModeVoteUpdate(GameModeVoteUpdate),
    /// Notification of the chosen mode.
    GameModeChosen(GameModeChosen),
    /// Custom text message.
    CustomMessage { text: String },
}

backend/src/server/mod.rs:
// src/server/mod.rs

//! Server layer root module.
//!
//! This module organizes the main backend server components, including:
//! - Application state management
//! - HTTP/WebSocket routing
//! - Matchmaking logic (lobby, payments, player readiness)
//! - Game session orchestration (game lifecycle, player actions)

pub mod state;
pub mod router;
pub mod matchmaking;
pub mod game_session;
pub mod ws_error;
pub mod session_utils;
pub mod anti_spam;
pub mod ws_actor_utils;
backend/src/server/state.rs:
// src/server/state.rs

//! Application state for the backend server.
//!
//! Holds references to the main actor addresses (matchmaking and game session managers).
//! Used to share state between HTTP/WebSocket handlers and the actor system.

use actix::Addr;
use crate::server::matchmaking::server::MatchmakingServer;
use crate::server::game_session::server::GameSessionManager;

/// Shared application state, injected into HTTP/WebSocket handlers.
pub struct AppState {
    /// Address of the matchmaking server actor (handles lobby, payments, readiness).
    pub matchmaking_addr: Addr<MatchmakingServer>,
    /// Address of the game session manager actor (handles game orchestration).
    pub game_session_manager: Addr<GameSessionManager>,
}

impl AppState {
    /// Create a new AppState with the given actor addresses.
    pub fn new(
        matchmaking_addr: Addr<MatchmakingServer>,
        game_session_manager: Addr<GameSessionManager>
    ) -> Self {
        AppState {
            matchmaking_addr,
            game_session_manager,
        }
    }
}
backend/src/server/router.rs:
//! HTTP and WebSocket routing configuration.
//!
//! Defines the main endpoints for matchmaking and game sessions.
//! Each endpoint is handled by a dedicated WebSocket actor.

use actix_web::web;
use crate::server::matchmaking::session::ws_matchmaking;
use crate::server::game_session::session::ws_game;

/// Configure the application's HTTP/WebSocket routes.
///
/// Each route is handled by its respective actor, which manages the connection lifecycle
/// and business logic for that context.
pub fn config(cfg: &mut web::ServiceConfig) {
    cfg.service(
        web::resource("/ws/matchmaking")
            .to(ws_matchmaking)
    )
    .service(
        web::resource("/ws/game/{game_id}")
            .to(ws_game)
    );
}
backend/src/server/ws_actor_utils.rs:
use actix_web_actors::ws;
use serde_json::Value;
use actix::ActorContext;

use crate::server::ws_error::ws_error_message;
use crate::server::anti_spam::AntiSpamState;

/// Trait utilitaire pour les acteurs WebSocket (matchmaking, game, etc.)
pub trait WsActorUtils {
    fn anti_spam(&mut self) -> &mut AntiSpamState;
    fn player_id(&self) -> &str;

    /// Envoie un message de ban, ferme et stoppe l'acteur.
    fn send_ban_and_close<A>(&mut self, ctx: &mut ws::WebsocketContext<A>)
    where
        A: actix::Actor<Context = ws::WebsocketContext<A>>,
    {
        let player_id = self.player_id().to_string();
        let ban_remaining_secs = self.anti_spam().ban_remaining_secs(&player_id);
        let context = serde_json::json!({
            "wallet": self.player_id(),
            "ban_remaining_secs": ban_remaining_secs
        });
        ctx.text(ws_error_message(
            "BANNED",
            "You have been banned for spamming. Please try again later.",
            Some(context),
        ));
        ctx.close(Some(ws::CloseReason {
            code: ws::CloseCode::Policy,
            description: Some("Banned for spam".into()),
        }));
        ctx.stop();
    }

    /// Envoie une erreur, applique anti-spam, et ban si besoin.
    fn send_error_and_maybe_ban<A>(
        &mut self,
        ctx: &mut ws::WebsocketContext<A>,
        code: &str,
        message: &str,
        context: Option<Value>,
    )
    where
        A: actix::Actor<Context = ws::WebsocketContext<A>>,
    {
        let player_id = self.player_id().to_string();
        if self.anti_spam().should_send_error(code, &player_id) {
            let player_id = self.player_id().to_string();
            if self.anti_spam().record_response(&player_id) {
                self.send_ban_and_close(ctx);
                return;
            }
            ctx.text(ws_error_message(code, message, context));
        }
    }

    /// Envoie une réponse JSON, ou ban si anti-spam dépassé.
    fn send_json_or_ban<A>(
        &mut self,
        ctx: &mut ws::WebsocketContext<A>,
        json_str: String,
    )
    where
        A: actix::Actor<Context = ws::WebsocketContext<A>>,
    {
        let player_id = self.player_id().to_string();
        if self.anti_spam().record_response(&player_id) {
            self.send_ban_and_close(ctx);
            return;
        }
        ctx.text(json_str);
    }
}
backend/src/server/ws_error.rs:
/// Centralized helpers for WebSocket and HTTP error responses.
///
/// Use these helpers to ensure all error messages are consistent, explicit, and include a code and context.
use actix_web::{HttpResponse, http::StatusCode};
use log::{warn, error};
use serde_json::{json, Value};

/// Formats a WebSocket error message as a JSON string.
///
/// # Arguments
/// - `code`: Unique error code (e.g. "INVALID_ACTION").
/// - `message`: Human-readable error message (in English).
/// - `context`: Optional context (can be a string or a JSON object).
pub fn ws_error_message<S: AsRef<str>>(code: S, message: S, context: Option<Value>) -> String {
    let mut data = json!({
        "code": code.as_ref(),
        "message": message.as_ref(),
    });

    if let Some(ref ctx) = context {
        data["context"] = ctx.clone();
    }

    let json_msg = json!({
        "action": "Error",
        "data": data
    });

    let result = json_msg.to_string();
    
    // Log the error with a simplified context representation
    let context_str = match &context {
        Some(ctx) => format!("{}", ctx),
        None => "None".to_string(),
    };
    warn!("[WS_ERROR] code={} message='{}' context={}", code.as_ref(), message.as_ref(), context_str);
    
    result
}

/// Example usage for a temporary ban:
/// ```
/// let ban_remaining_secs = 42;
/// let wallet = "0x123...";
/// let context = json!({
///     "wallet": wallet,
///     "ban_remaining_secs": ban_remaining_secs
/// });
/// let msg = ws_error_message("BANNED", "You have been banned for spamming. Please try again later.", Some(context));
/// ```

/// Returns a WebSocket message for session kicked (unicity violation).
pub fn ws_session_kicked_message(context: Option<Value>) -> String {
    ws_error_message(
        "SESSION_KICKED",
        "You have been disconnected because another session has connected with your wallet.",
        context,
    )
}

/// Returns an HTTP error response with a JSON body.
///
/// # Arguments
/// - `code`: Unique error code.
/// - `message`: Human-readable error message.
/// - `context`: Optional context (can be a string or a JSON object).
/// - `status`: HTTP status code.
pub fn http_error_response<S: AsRef<str>>(
    code: S,
    message: S,
    context: Option<Value>,
    status: StatusCode,
) -> HttpResponse {
    let mut error_data = json!({
        "code": code.as_ref(),
        "message": message.as_ref(),
    });

    if let Some(ref ctx) = context {
        error_data["context"] = ctx.clone();
    }

    let body = json!({
        "error": error_data
    }).to_string();

    // Log the error with a simplified context representation
    let context_str = match &context {
        Some(ctx) => format!("{}", ctx),
        None => "None".to_string(),
    };
    error!("[HTTP_ERROR] code={} message='{}' context={}", code.as_ref(), message.as_ref(), context_str);
    
    HttpResponse::build(status).content_type("application/json").body(body)
}

backend/src/server/anti_spam.rs:
use std::time::{Instant, Duration};
use log::warn;

use crate::config::anti_spam::{MAX_RESPONSES_PER_SECOND, MAX_REQUESTS_PER_SECOND, BAN_DURATION_SECONDS};

/// Tracks anti-spam state for a single session (player or spectator).
pub struct AntiSpamState {
    // Last error code sent (for suppression)
    last_error_code: Option<String>,
    // Timestamp of last reset (for per-second counters)
    last_tick: Instant,
    // Number of responses sent in the current second
    responses_this_tick: u32,
    // Number of requests received in the current second
    requests_this_tick: u32,
    // Ban state
    banned_until: Option<Instant>,
}

impl AntiSpamState {
    pub fn new() -> Self {
        Self {
            last_error_code: None,
            last_tick: Instant::now(),
            responses_this_tick: 0,
            requests_this_tick: 0,
            banned_until: None,
        }
    }

    /// Call at the start of every incoming request (message).
    /// Returns true if the session is currently banned.
    pub fn record_request(&mut self, wallet: &str) -> bool {
        self.tick();
        self.requests_this_tick += 1;
        if self.requests_this_tick > MAX_REQUESTS_PER_SECOND {
            self.ban(wallet, "Too many requests per second");
            return true;
        }
        self.is_banned()
    }

    /// Call at the start of every outgoing response (including errors).
    /// Returns true if the session is currently banned.
    pub fn record_response(&mut self, wallet: &str) -> bool {
        self.tick();
        self.responses_this_tick += 1;
        if self.responses_this_tick > MAX_RESPONSES_PER_SECOND {
            self.ban(wallet, "Too many responses per second");
            return true;
        }
        self.is_banned()
    }

    /// Call when sending an error. Returns true if the error should be sent (not suppressed).
    pub fn should_send_error(&mut self, error_code: &str, wallet: &str) -> bool {
        if let Some(last) = &self.last_error_code {
            if last == error_code {
                // Suppress duplicate error
                warn!("[AntiSpam] Suppressed duplicate error '{}' for wallet={}", error_code, wallet);
                return false;
            }
        }
        self.last_error_code = Some(error_code.to_string());
        true
    }

    /// Call when a valid action is performed (state-changing, not error).
    pub fn reset_on_valid_action(&mut self) {
        self.last_error_code = None;
        // Optionally, could reset counters here if desired
    }

    /// Call to reset error suppression (e.g., at start of new turn or phase).
    pub fn reset_error_suppression(&mut self) {
        self.last_error_code = None;
    }

    /// Returns true if the session is currently banned.
    pub fn is_banned(&self) -> bool {
        if let Some(until) = self.banned_until {
            Instant::now() < until
        } else {
            false
        }
    }

    /// Returns the ban expiry time, if banned.
    pub fn ban_expiry(&self) -> Option<Instant> {
        self.banned_until
    }

    /// Returns the remaining ban duration in seconds, or 0 if not banned.
    pub fn ban_remaining_secs(&self, _wallet: &str) -> u64 {
        if let Some(until) = self.banned_until {
            let now = Instant::now();
            if until > now {
                return (until - now).as_secs();
            }
        }
        0
    }

    /// Ban the session for BAN_DURATION_SECONDS.
    fn ban(&mut self, wallet: &str, reason: &str) {
        let until = Instant::now() + Duration::from_secs(BAN_DURATION_SECONDS);
        self.banned_until = Some(until);
        warn!("[AntiSpam] Banned wallet={} until {:?} for reason: {}", wallet, until, reason);
    }

    /// Reset per-second counters if a new second has started.
    fn tick(&mut self) {
        let now = Instant::now();
        if now.duration_since(self.last_tick) >= Duration::from_secs(1) {
            self.last_tick = now;
            self.responses_this_tick = 0;
            self.requests_this_tick = 0;
        }
    }
}

