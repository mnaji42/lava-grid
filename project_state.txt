1. stuctures de fichiers:

src
|____state.rs
|____types.rs
|____game.rs
|____main.rs
|____tests.rs
|____systems
| |____rules.rs
| |____movement.rs
| |____render.rs
| |____mod.rs
|____utils.rs
|____entities
| |____cannonball.rs
| |____mod.rs
| |____player.rs
|____grid
| |____grid.rs
| |____mod.rs
Cargo.toml
Cargo.lock

//program/src/lib.rs
pub fn add(left: u64, right: u64) -> u64 {
    left + right
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn it_works() {
        let result = add(2, 2);
        assert_eq!(result, 4);
    }
}

pub fn say_hello() {
    println!("Hello from the program library!");
}


//src/entities/cannonball.rs
use crate::types::{Player, Cell, Position, Cannonball};
use rand::seq::IteratorRandom;

pub fn spawn_random_cannonballs(
    grid: &Vec<Vec<Cell>>,
    players: &Vec<Player>,
    existing_cannonballs: usize,
    count: usize,
) -> Vec<Cannonball> {
    let mut rng = rand::rng();

    let valid_positions: Vec<Position> = grid.iter().enumerate()
        .flat_map(|(x, row)| row.iter().enumerate().filter_map(move |(y, cell)| {
            if *cell == Cell::Solid {
                Some(Position { x, y })
            } else {
                None
            }
        }))
        .collect();

    let occupied_positions: Vec<Position> = players.iter().map(|p| p.pos)
        .chain(std::iter::repeat(Position { x: 0, y: 0 }).take(existing_cannonballs)) // Faux pour l’instant
        .collect();

    let free_positions: Vec<Position> = valid_positions
        .into_iter()
        .filter(|pos| !occupied_positions.contains(pos))
        .collect();

    if free_positions.len() == 0 {
        println!("[WARN] Aucune case libre pour placer un boulet !");
        return vec![];
    }

    free_positions.iter()
        .choose_multiple(&mut rng, count.min(free_positions.len()))
        .into_iter()
        .map(|pos| Cannonball { pos: *pos })
        .collect()
}



//src/entities/mod.rs


//src/entities/player.rs
use crate::types::{Player, Cell, Position};
use rand::seq::IteratorRandom;

/// Generate new player with random position
pub fn spawn_random_player(
    grid: &Vec<Vec<Cell>>,
    players: &Vec<Player>,
    id: u8,
) -> Option<Player> {
    let mut rng = rand::rng();

    let valid_positions: Vec<Position> = grid.iter().enumerate()
        .flat_map(|(x, row)| {
            row.iter().enumerate().filter_map(move |(y, cell)| {
                if *cell == Cell::Solid && !players.iter().any(|p| p.pos.x == x && p.pos.y == y) {
                    Some(Position { x, y })
                } else {
                    None
                }
            })
        })
        .collect();

    if valid_positions.len() == 0 {
        println!("[WARN] Impossible de placer le joueur {} : aucune case libre.", id);
        return None;
    }

    valid_positions.into_iter()
        .choose(&mut rng)
        .map(|pos| Player::new(id, pos))
}

//src/grid/grid.rs
use crate::types::{Cell};
use rand::{seq::IteratorRandom};

pub fn generate_grid(rows: usize, cols: usize) -> Vec<Vec<Cell>> {
    vec![vec![Cell::Solid; cols]; rows]
}

fn is_cell_breakable(cell: Cell) -> bool {
    cell == Cell::Solid
}


pub fn break_tile(grid: &mut Vec<Vec<Cell>>) {
    let mut rng = rand::rng();
    let solid_tiles: Vec<(usize, usize)> = grid.iter().enumerate()
        .flat_map(|(x, row)| row.iter().enumerate().filter_map(move |(y, cell)| {
            if is_cell_breakable(*cell) {
                Some((x, y))
            } else {
                None
            }
        }))
        .collect();

    if let Some(&(x, y)) = solid_tiles.iter().choose(&mut rng) {
        grid[x][y] = Cell::Broken;
    }
}



//src/grid/mod.rs


//src/systems/mod.rs


//src/systems/movement.rs
use crate::types::{Direction, Position};
use crate::state::GameState;

pub fn move_player(game_state: &mut GameState, player_index: usize, direction: Direction) -> Position {
    let player = &mut game_state.players[player_index];
    let mut new_pos = player.pos;

    match direction {
        Direction::Up => if new_pos.x > 0 { new_pos.x -= 1; },
        Direction::Down => if new_pos.x < game_state.grid.len() - 1 { new_pos.x += 1; },
        Direction::Left => if new_pos.y > 0 { new_pos.y -= 1; },
        Direction::Right => if new_pos.y < game_state.grid[0].len() - 1 { new_pos.y += 1; },
        Direction::Stay => {}
    }

    player.pos = new_pos;
    new_pos
}




//src/systems/render.rs
use crate::types::{Player, Cell, Cannonball};

// pub fn build_display_grid(
//     grid: &Vec<Vec<Cell>>,
//     players: &Vec<Player>,
//     cannonballs: &Vec<Cannonball>,
// ) -> Vec<Vec<char>> {
//     let mut display = grid.iter().map(|row| {
//         row.iter().map(|cell| match cell {
//             Cell::Solid => '.',
//             Cell::Broken => '~',
//         }).collect::<Vec<_>>()
//     }).collect::<Vec<_>>();

//     for cannon in cannonballs {
//         display[cannon.pos.x][cannon.pos.y] = 'B';
//     }

//     for player in players {
//         if player.is_alive {
//             display[player.pos.x][player.pos.y] = char::from_digit(player.id as u32, 10).unwrap_or('P');
//         }
//     }

//     display
// }

pub fn print_grid(grid: &Vec<Vec<Cell>>, players: &Vec<Player>, cannonballs: &Vec<Cannonball>) {
    for (x, row) in grid.iter().enumerate() {
        for (y, cell) in row.iter().enumerate() {
            let mut symbol = match cell {
                Cell::Solid => "██".to_string(),
                Cell::Broken => "  ".to_string(),
            };

            // Priorité à l'affichage du joueur puis cannonball
            if let Some(player) = players.iter().find(|p| p.pos.x == x && p.pos.y == y && p.is_alive) {
                symbol = format!("P{}", player.id);
            } else if let Some(_) = cannonballs.iter().find(|c| c.pos.x == x && c.pos.y == y) {
                symbol = "CB".to_string();
            }

            print!("{:<3}", symbol);
        }
        println!("\n");
    }
}

pub fn print_player_state(player: &Player) {
    println!("--- Player {} ---", player.id);
    println!("Position: ({}, {})", player.pos.x, player.pos.y);
    println!("Cannonballs: {}", player.cannonball_count);
    println!();
}


//src/systems/rules.rs
use crate::types::{Cell};
use crate::state::GameState;

pub fn apply_rules(game_state: &mut GameState, player_index: usize) {

    let player = &mut game_state.players[player_index];
    // Check if there is a tile at the new pos
    if game_state.grid[player.pos.x][player.pos.y] == Cell::Broken {
        player.is_alive = false;
    }

    // Try to picj up cannonball
    if let Some(pos) = game_state.cannonballs.iter().position(|c| c.pos == player.pos) {
        player.cannonball_count += 1;
        game_state.cannonballs.remove(pos);
    }
}



//src/game.rs
use crate::systems::{movement::move_player, rules::apply_rules, render::print_player_state,render::print_grid};
use crate::types::{Direction};
use crate::state::GameState;

use std::io::{self, Write};

fn get_player_input() -> Direction {
    print!("Enter direction (← ↑ ↓ → or Space), then press Enter: ");
    io::stdout().flush().unwrap();

    let mut input = String::new();
    io::stdin().read_line(&mut input).unwrap();

    match input.trim() {
        "\x1b[D" => Direction::Left,
        "\x1b[C" => Direction::Right,
        "\x1b[A" => Direction::Up,
        "\x1b[B" => Direction::Down,
        _ => Direction::Stay,
    }
}

pub fn run_game_loop() {
    let player_id = 0;
    let mut game_state = GameState::new(5, 5, 1); // Initialisation de l'état du jeu

    println!("Game start!");
    print_player_state(&game_state.players[0]);
    print_grid(&game_state.grid, &game_state.players, &game_state.cannonballs);

    loop {
        let direction = get_player_input();
        move_player(&mut game_state, player_id, direction);
        
        apply_rules(&mut game_state, player_id);

        game_state.next_turn(); // Passer au tour suivant

        print_player_state(&game_state.players[0]);
        print_grid(&game_state.grid, &game_state.players, &game_state.cannonballs);

        if !game_state.players[0].is_alive {
            println!("Player {} is dead. Game Over!", game_state.players[0].id);
            break;
        }
    }
}



src/main.rs
mod game;
mod types;
mod utils;
mod state;

mod entities {
    pub mod player;
    pub mod cannonball;
}

mod grid {
    pub mod grid;
}

mod systems {
    pub mod movement;
    pub mod rules;
    pub mod render;
}

use crate::game::run_game_loop;

fn main() {
    run_game_loop();
}

//state.rs
use crate::types::{Player, Cannonball, Position, Cell};
use crate::grid::grid::{generate_grid, break_tile};
use crate::entities::player::{spawn_random_player};
use crate::entities::cannonball::{spawn_random_cannonballs};
use rand::Rng;

pub struct GameState {
    pub grid: Vec<Vec<Cell>>,
    pub players: Vec<Player>,
    pub cannonballs: Vec<Cannonball>,
    pub turn: u32,
}

impl GameState {
    // Crée un nouvel état de jeu
    pub fn new(rows: usize, cols: usize, player_count: usize) -> Self {
        let mut players = vec![];
        for id in 1..=player_count {
            if let Some(player) = spawn_random_player(&generate_grid(rows, cols), &players, id as u8) {
                players.push(player);
            }
        }

        let cannonballs = spawn_random_cannonballs(&generate_grid(rows, cols), &players, 0, rand::thread_rng().gen_range(1..=3));

        GameState {
            grid: generate_grid(rows, cols),
            players,
            cannonballs,
            turn: 1,
        }
    }

    // Passe au tour suivant
    pub fn next_turn(&mut self) {
        self.turn += 1;
        break_tile(&mut self.grid);  // Cassure de tuile à chaque tour
    }
}



//src/tests.rs
#[cfg(test)]
mod tests {
    use super::*;
    use crate::{grid::*, player::*, cannonball::*, types::*};

    #[test]
    fn test_grid_generation_size() {
        let grid = create_grid(10, 10);
        assert_eq!(grid.len(), 10);
        assert!(grid.iter().all(|row| row.len() == 10));
    }

    #[test]
    fn test_player_spawn_no_overlap() {
        let grid = create_grid(10, 10);
        let mut players = vec![];

        for id in 0..5 {
            let player = spawn_random_player(&grid, &players, id).expect("Failed to spawn player");
            assert!(!players.iter().any(|p| p.pos == player.pos));
            players.push(player);
        }
    }

    #[test]
    fn test_spawn_player_no_space() {
        let mut grid = vec![vec![Cell::Lava; 5]; 5]; // aucune case valide
        let players = vec![];
        let player = spawn_random_player(&grid, &players, 0);
        assert!(player.is_none());
    }

    #[test]
    fn test_cannonball_spawn_limit() {
        let grid = create_grid(5, 5);
        let players = vec![];
        let cannonballs = spawn_random_cannonballs(&grid, &players, 0, 100);
        assert!(cannonballs.len() <= 25); // au max 25 tiles solides
    }

    #[test]
    fn test_move_player_into_lava() {
        let mut grid = create_grid(5, 5);
        let mut player = Player::new(1, Position { x: 2, y: 2 });

        grid[2][3] = Cell::Lava;
        move_player(&mut player, Direction::Right, &grid);

        assert!(!player.is_alive);
    }

    #[test]
    fn test_pickup_cannonball() {
        let grid = create_grid(5, 5);
        let mut player = Player::new(1, Position { x: 2, y: 2 });
        let cannonball_pos = Position { x: 2, y: 3 };
        let mut cannonballs = vec![Cannonball { pos: cannonball_pos }];

        move_player(&mut player, Direction::Right, &grid);
        try_pickup_cannonball(&mut player, &mut cannonballs);

        assert_eq!(player.cannonball_count, 1);
        assert!(cannonballs.is_empty());
    }

    #[test]
    fn test_break_tile_replaces_with_lava() {
        let mut grid = create_grid(5, 5);
        let mut rng = rand::rng();

        break_tile(&mut grid, &mut rng);
        let lava_count = grid.iter().flatten().filter(|&&c| c == Cell::Lava).count();
        assert_eq!(lava_count, 1);
    }

    #[test]
    fn test_player_does_not_spawn_on_object() {
        let mut grid = create_grid(5, 5);
        let mut players = vec![];
        let mut cannonballs = vec![
            Cannonball { pos: Position { x: 1, y: 1 } },
            Cannonball { pos: Position { x: 2, y: 2 } },
        ];

        for id in 0..10 {
            if let Some(p) = spawn_random_player(&grid, &players, id) {
                // Le joueur ne spawn pas sur un cannonball
                assert!(!cannonballs.iter().any(|c| c.pos == p.pos));
                players.push(p);
            }
        }
    }
}



//src/types.rs
// types.rs

#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
pub struct Position {
    pub x: usize,
    pub y: usize,
}

#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
pub enum Direction {
    Up,
    Down,
    Left,
    Right,
    Stay,
}

#[derive(Debug, Clone, Copy, PartialEq)]
pub enum Cell {
    Solid,
    Broken,
}

#[derive(Debug, Clone)]
pub struct Player {
    pub id: u8,
    pub pos: Position,
    pub cannonball_count: u32,
    pub is_alive: bool,
}

impl Player {
    pub fn new(id: u8, pos: Position) -> Self {
        Self {
            id,
            pos,
            cannonball_count: 0,
            is_alive: true,
        }
    }
}

#[derive(Debug, Clone)]
pub struct Cannonball {
    pub pos: Position,
}



//src/utils.rs

